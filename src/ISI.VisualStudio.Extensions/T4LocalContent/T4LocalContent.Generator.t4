<#
/*
Copyright (c) 2022, Integrated Solutions, Inc.
All rights reserved.

Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:

		* Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
		* Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
		* Neither the name of the Integrated Solutions, Inc. nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/
#>
<#@ assembly name="System.Core" #>
<#@ assembly name="Microsoft.VisualStudio.Shell.Interop.8.0" #>
<#@ assembly name="EnvDTE" #>
<#@ assembly name="EnvDTE80" #>
<#@ assembly name="VSLangProj" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Text.RegularExpressions" #>
<#@ import namespace="Microsoft.VisualStudio.Shell.Interop" #>
<#@ import namespace="EnvDTE" #>
<#@ import namespace="EnvDTE80" #>
<#@ import namespace="Microsoft.VisualStudio.TextTemplating" #>
<#		Initialize(); #>
// <auto-generated />
// Make sure the compiler doesn't complain about missing Xml comments
#pragma warning disable 1591

using System;
using System.Diagnostics;
using System.CodeDom.Compiler;
using System.Collections.Generic;
using System.Linq;
using System.Runtime.CompilerServices;

<#
		if (BuildT4Files)
		{
			var separator = "/";
#>
#region <#= Namespace #><#= (string.IsNullOrWhiteSpace(FilesSubClassName) ? string.Empty : string.Format(".{0}", FilesSubClassName)) #>
namespace <#= Namespace #>
{
<#
				foreach (var subClassName in FilesSubClassNames)
				{
					PushIndent("\t");
#>
[<#= 		GeneratedCode #>, DebuggerNonUserCode]
public static partial class <#= subClassName #>
{
<#
				}

#>
	public static string __root = <#= (IsWebRoot ? "\"~/\"" : "null") #>;
	public static string _root()
	{
		return (__root ?? (__root = ISI.Libraries.Configuration.GetUrlRoot(typeof(<#= FilesSubClassName #>))));
	}

<#

			var classNamespace = FilesSubClassName;

			foreach (ProjectItem projectItem in Project.ProjectItems)
			{
				if (RootFileNames.Exists(fileName => string.Equals(fileName, projectItem.Name, StringComparison.InvariantCultureIgnoreCase)))
				{
#>
	public static readonly string <#= CreateSlug(projectItem.Name) #> = _root() + "<#= projectItem.Name #>";
<#
				}
			}

				foreach (ProjectItem folderItem in Project.ProjectItems)
				{
					if (IsFolder(folderItem))
					{
						if (string.Equals(ViewsFolder, folderItem.Name, StringComparison.InvariantCultureIgnoreCase) || LocalContentFileFolders.Any(name => string.Equals(name, folderItem.Name, StringComparison.InvariantCultureIgnoreCase)))
						{
							Files_ProcessContentFolder(folderItem, classNamespace, separator);
						}
						if (string.Equals(AreasRootFolder, folderItem.Name, StringComparison.InvariantCultureIgnoreCase))
						{
							PushIndent("\t");
#>
[<#= 						GeneratedCode #>, DebuggerNonUserCode]
public static partial class Areas
{
	public static string _root()
	{
		return string.Format("{0}Areas<#= separator #>", <#= classNamespace #>._root());
	}

<#
							foreach (ProjectItem areaItem in folderItem.ProjectItems)
							{
								if (IsFolder(areaItem))
								{
									Files_ProcessArea(areaItem, string.Format("{0}.Areas", classNamespace), separator);
								}
							}
#>
}
<#
							PopIndent();
						}
					}
				}

				foreach (var subClassName in FilesSubClassNames)
				{
#>
}
<#
					PopIndent();
				}
#>
}
#endregion

<#
		}

		if (BuildT4Links)
		{
#>
#region <#= Namespace #><#= (string.IsNullOrWhiteSpace(LinksSubClassName) ? string.Empty : string.Format(".{0}", LinksSubClassName)) #>
namespace <#= Namespace #>
{
<#
				foreach (var subClassName in LinksSubClassNames)
				{
					PushIndent("\t");
#>
[<#= 		GeneratedCode #>, DebuggerNonUserCode]
public static partial class <#= subClassName #>
{
	public static Func<string, bool, global::ISI.Libraries.Web.IContentUrl> GetContentUrl = (url, isOrignalUrl) => new global::ISI.Libraries.Web.ContentUrl(url, isOrignalUrl);

	[ISI.Libraries.Web.ContentUrlGeneratorSetter]
	public class ContentUrlGeneratorSetter : global::ISI.Libraries.Web.IContentUrlGeneratorSetter
	{
		public void SetContentUrlGenerator(Func<string, bool, global::ISI.Libraries.Web.IContentUrl> setter)
		{
			GetContentUrl = setter;
		}
	}

<#
				}

#>
	public static string __root = <#= (IsWebRoot ? "\"~/\"" : "null") #>;
	public static string _root()
	{
		return (__root ?? (__root = ISI.Libraries.Configuration.GetUrlRoot(typeof(<#= LinksSubClassName #>))));
	}

<#
			var classNamespace = LinksSubClassName;

			var hasRootItem = false;
			foreach (ProjectItem projectItem in Project.ProjectItems)
			{
				if (RootFileNames.Exists(fileName => string.Equals(fileName, projectItem.Name, StringComparison.InvariantCultureIgnoreCase)))
				{
					if (!hasRootItem)
					{
#>
	private static global::ISI.Libraries.Web.IContentUrl _directory = null;
	public static global::ISI.Libraries.Web.IContentUrl _Directory => _directory ?? (_directory = GetContentUrl(_root(), true));
<#
						hasRootItem = true;
					}
#>
	public static readonly global::ISI.Libraries.Web.IContentUrl <#= CreateSlug(projectItem.Name) #> = GetContentUrl(_root() + "<#= projectItem.Name #>", true);
<#
				}
			}
				if (hasRootItem)
				{
#>

<#
				}

				foreach (ProjectItem folderItem in Project.ProjectItems)
				{
					if (IsFolder(folderItem))
					{
						if (string.Equals(AreasRootFolder, folderItem.Name, StringComparison.InvariantCultureIgnoreCase))
						{
							PushIndent("\t");
#>
[<#= 						GeneratedCode #>, DebuggerNonUserCode]
public static partial class Areas
{
	public static string _root()
	{
		return string.Format("{0}Areas/", <#= classNamespace #>._root());
	}

<#
							foreach (ProjectItem areaItem in folderItem.ProjectItems)
							{
								if (IsFolder(areaItem))
								{
									Links_ProcessArea(areaItem, string.Format("{0}.Areas", classNamespace));
								}
							}
#>
}
<#
							PopIndent();
						}
						if (LocalContentFileFolders.Any(name => string.Equals(name, folderItem.Name, StringComparison.InvariantCultureIgnoreCase)))
						{
							Links_ProcessContentFolder(folderItem, classNamespace);
						}
					}
				}

				foreach (var subClassName in LinksSubClassNames)
				{
#>
}
<#
					PopIndent();
				}
#>
}
#endregion
<#
		}

		if (BuildT4Embedded)
		{
			var separator = "/";
#>

#region <#= Namespace #><#= (string.IsNullOrWhiteSpace(EmbeddedSubClassName) ? string.Empty : string.Format(".{0}", EmbeddedSubClassName)) #>
namespace <#= Namespace #>
{
<#
				foreach (var subClassName in EmbeddedSubClassNames)
				{
					PushIndent("\t");
#>
[<#= 		GeneratedCode #>, DebuggerNonUserCode]
public static partial class <#= subClassName #>
{
<#
				}

#>
	public static string _root()
	{
		return "pack://application:,,,/<#= Namespace #>;component/";
	}

<#

			var classNamespace = EmbeddedSubClassName;

			foreach (ProjectItem projectItem in Project.ProjectItems)
			{
				if (RootFileNames.Exists(fileName => string.Equals(fileName, projectItem.Name, StringComparison.InvariantCultureIgnoreCase)))
				{
#>
	public static readonly string <#= CreateSlug(projectItem.Name) #> = _root() + "<#= projectItem.Name #>";
<#
				}
			}

				foreach (ProjectItem folderItem in Project.ProjectItems)
				{
					if (IsFolder(folderItem))
					{
						if (string.Equals(ViewsFolder, folderItem.Name, StringComparison.InvariantCultureIgnoreCase) || LocalContentFileFolders.Any(name => string.Equals(name, folderItem.Name, StringComparison.InvariantCultureIgnoreCase)))
						{
							Files_ProcessContentFolder(folderItem, classNamespace, separator);
						}
						if (string.Equals(AreasRootFolder, folderItem.Name, StringComparison.InvariantCultureIgnoreCase))
						{
							PushIndent("\t");
#>
[<#= 						GeneratedCode #>, DebuggerNonUserCode]
public static partial class Areas
{
	public static string _root()
	{
		return string.Format("{0}Areas<#= separator #>", <#= classNamespace #>._root());
	}

<#
							foreach (ProjectItem areaItem in folderItem.ProjectItems)
							{
								if (IsFolder(areaItem))
								{
									Files_ProcessArea(areaItem, string.Format("{0}.Areas", classNamespace), separator);
								}
							}
#>
}
<#
							PopIndent();
						}
					}
				}

				foreach (var subClassName in EmbeddedSubClassNames)
				{
#>
}
<#
					PopIndent();
				}
#>
}
#endregion

<#
		}

		if (BuildT4Resources)
		{
			var separator = ".";
#>
#region <#= Namespace #><#= (string.IsNullOrWhiteSpace(ResourcesSubClassName) ? string.Empty : string.Format(".{0}", ResourcesSubClassName)) #>
namespace <#= Namespace #>
{
<#
				foreach (var subClassName in ResourcesSubClassNames)
				{
					PushIndent("\t");
#>
[<#= 		GeneratedCode #>, DebuggerNonUserCode]
public static partial class <#= subClassName #>
{
<#
				}

#>
	public static string _root()
	{
		return "<#= Namespace #>.";
	}

<#

			var classNamespace = ResourcesSubClassName;

			foreach (ProjectItem projectItem in Project.ProjectItems)
			{
				if (RootFileNames.Exists(fileName => string.Equals(fileName, projectItem.Name, StringComparison.InvariantCultureIgnoreCase)))
				{
#>
	public static readonly string <#= CreateSlug(projectItem.Name) #> = _root() + "<#= projectItem.Name #>";
	public static System.IO.Stream Get<#= CreateSlug(projectItem.Name) #>Stream()
	{
		return typeof(<#= Namespace #>.<#= ResourcesSubClassName #>).Assembly.GetManifestResourceStream(<#= CreateSlug(projectItem.Name) #>);
	}
<#
				}
			}

				foreach (ProjectItem folderItem in Project.ProjectItems)
				{
					if (IsFolder(folderItem))
					{
						if (string.Equals(ViewsFolder, folderItem.Name, StringComparison.InvariantCultureIgnoreCase) || LocalContentFileFolders.Any(name => string.Equals(name, folderItem.Name, StringComparison.InvariantCultureIgnoreCase)))
						{
							Files_ProcessContentFolder(folderItem, classNamespace, separator);
						}
						if (string.Equals(AreasRootFolder, folderItem.Name, StringComparison.InvariantCultureIgnoreCase))
						{
							PushIndent("\t");
#>
[<#= 						GeneratedCode #>, DebuggerNonUserCode]
public static partial class Areas
{
	public static string _root()
	{
		return string.Format("{0}Areas<#= separator #>", <#= classNamespace #>._root());
	}

<#
							foreach (ProjectItem areaItem in folderItem.ProjectItems)
							{
								if (IsFolder(areaItem))
								{
									Files_ProcessArea(areaItem, string.Format("{0}.Areas", classNamespace), separator);
								}
							}
#>
}
<#
							PopIndent();
						}
					}
				}

				foreach (var subClassName in ResourcesSubClassNames)
				{
#>
}
<#
					PopIndent();
				}
#>
}
#endregion

<#
		}
#>

<#+ 
		private void Files_ProcessArea(ProjectItem projectItem, string classNamespace, string separator)
		{
			var projectItemSlug = CreateSlug(projectItem.Name);
			PushIndent("\t");
#>
[<#= 			GeneratedCode #>, DebuggerNonUserCode]
public static partial class <#= projectItemSlug #>
{
	public static string _root()
	{
		return string.Format("{0}<#= projectItem.Name #><#= separator #>", <#= classNamespace #>._root());
	}

<#+
			foreach (ProjectItem folderItem in projectItem.ProjectItems)
			{
				if (IsFolder(folderItem))
				{
					if (string.Equals(ViewsFolder, folderItem.Name, StringComparison.InvariantCultureIgnoreCase) || LocalContentFileFolders.Any(name => string.Equals(name, folderItem.Name, StringComparison.InvariantCultureIgnoreCase)))
					{
						Files_ProcessContentFolder(folderItem, string.Format("{0}.{1}", classNamespace, projectItemSlug), separator);
					}
				}
			}
#>
}
<#+
			PopIndent();
		}

		private void Files_ProcessContentFolder(ProjectItem projectFolder, string classNamespace, string separator)
		{
			var projectFolderSlug = CreateSlug(projectFolder.Name);
			PushIndent("\t");
#>
[<#= 			GeneratedCode #>, DebuggerNonUserCode]
public static partial class <#= projectFolderSlug #>
{
	public static string _root()
	{
		return string.Format("{0}<#= projectFolder.Name #><#= separator #>", <#= classNamespace #>._root());
	}

<#+
			var usedNames = new List<string>();
			foreach (ProjectItem projectItem in projectFolder.ProjectItems)
			{
				if (IsFolder(projectItem))
				{
					if (!usedNames.Contains(projectItem.Name))
					{
						Files_ProcessContentFolder(projectItem, string.Format("{0}.{1}", classNamespace, projectFolderSlug), separator);
						usedNames.Add(projectItem.Name);
					}
				}
				else if (!LocalContentFileIgnoreFileExtensions.Any(e => projectItem.Name.EndsWith(e, StringComparison.InvariantCultureIgnoreCase)))
				{
					foreach (var fileName in ExpandFileName(projectItem.Name))
					{
						if (!usedNames.Contains(fileName))
						{
#>
	public static readonly string <#= CreateSlug(fileName, projectFolderSlug) #> = _root() + "<#= projectItem.Name #>";
	public static System.IO.Stream Get<#= CreateSlug(projectItem.Name) #>Stream()
	{
		return typeof(<#= Namespace #>.<#= ResourcesSubClassName #>).Assembly.GetManifestResourceStream(<#= CreateSlug(projectItem.Name) #>);
	}
<#+
							usedNames.Add(fileName);
						}
					}
				}
			}
#>
}
<#+
			PopIndent();
		}

		private void Links_ProcessArea(ProjectItem projectItem, string classNamespace)
		{
			var projectItemSlug = CreateSlug(projectItem.Name);
			PushIndent("\t");
#>
[<#= 			GeneratedCode #>, DebuggerNonUserCode]
public static partial class <#= projectItemSlug #>
{
	public static string _root()
	{
		return string.Format("{0}<#= projectItem.Name #>/", <#= classNamespace #>._root());
	}

<#+
			foreach (ProjectItem folderItem in projectItem.ProjectItems)
			{
				if (IsFolder(folderItem))
				{
					if (LocalContentFileFolders.Any(name => string.Equals(name, folderItem.Name, StringComparison.InvariantCultureIgnoreCase)))
					{
						Links_ProcessContentFolder(folderItem, string.Format("{0}.{1}", classNamespace, projectItemSlug));
					}
				}
			}
#>
}
<#+
			PopIndent();
		}

		private void Links_ProcessContentFolder(ProjectItem projectFolder, string classNamespace)
		{
			var projectFolderSlug = CreateSlug(projectFolder.Name);
			PushIndent("\t");
#>
[<#= 			GeneratedCode #>, DebuggerNonUserCode]
public static partial class <#= projectFolderSlug #>
{
	public static string _root()
	{
		return string.Format("{0}<#= projectFolder.Name #>/", <#= classNamespace #>._root());
	}

	private static global::ISI.Libraries.Web.IContentUrl _directory = null;
	public static global::ISI.Libraries.Web.IContentUrl _Directory => _directory ?? (_directory = GetContentUrl(<#= classNamespace #>._root() + "<#= projectFolder.Name #>", true));

<#+
			var usedNames = new List<string>();
			foreach (ProjectItem projectItem in projectFolder.ProjectItems)
			{
				if (IsFolder(projectItem))
				{
					if (!usedNames.Contains(projectItem.Name))
					{
						Links_ProcessContentFolder(projectItem, string.Format("{0}.{1}", classNamespace, projectFolderSlug));
						usedNames.Add(projectItem.Name);
					}
				}
				else if (!LocalContentFileIgnoreFileExtensions.Any(e => projectItem.Name.EndsWith(e, StringComparison.InvariantCultureIgnoreCase)))
				{
					foreach (var fileName in ExpandFileName(projectItem.Name))
					{
						if (!usedNames.Contains(fileName))
						{
#>
	public static readonly global::ISI.Libraries.Web.IContentUrl <#= CreateSlug(fileName, projectFolderSlug) #> = GetContentUrl(_root() + "<#= projectItem.Name #>", true);
<#+
							usedNames.Add(fileName);
						}
					}
				}
			}
#>
}
<#+
			PopIndent();
		}

	static DTE Dte;
	static Project Project;
	static Microsoft.CSharp.CSharpCodeProvider codeProvider;
	static string GeneratedCode;
	static string[] FilesSubClassNames;
	static string[] LinksSubClassNames;
	static string[] EmbeddedSubClassNames;
	static string[] ResourcesSubClassNames;
	static Dictionary<System.Text.RegularExpressions.Regex, string> rgFileNameReplacements;

	private void Initialize()
	{
		var serviceProvider = Host as IServiceProvider;
		if (serviceProvider != null)
		{
			Dte = serviceProvider.GetService(typeof (SDTE)) as DTE;
		}

		Project = Dte.Solution.FindProjectItem(Host.TemplateFile).ContainingProject;

		codeProvider = new Microsoft.CSharp.CSharpCodeProvider();
		GeneratedCode = @"GeneratedCode(""T4LocalContent"", ""1.0"")";

		FilesSubClassNames = FilesSubClassName.Split(new string[] {"."}, StringSplitOptions.RemoveEmptyEntries);
		LinksSubClassNames = LinksSubClassName.Split(new string[] {"."}, StringSplitOptions.RemoveEmptyEntries);
		EmbeddedSubClassNames = EmbeddedSubClassName.Split(new string[] {"."}, StringSplitOptions.RemoveEmptyEntries);
		ResourcesSubClassNames = ResourcesSubClassName.Split(new string[] {"."}, StringSplitOptions.RemoveEmptyEntries);
	}

	private static List<string> ExpandFileName(string fileName)
	{
		var result = new List<string>();

		result.Add(fileName);
		if (LocalContentFileNameReplacements != null)
		{
			foreach (var fileNameReplacement in LocalContentFileNameReplacements)
			{
				if (fileNameReplacement.Key.Match(fileName).Success)
				{
					result.Add(fileNameReplacement.Value);
				}
			}
		}

		return result;
	}

	private static bool IsFolder(ProjectItem item)
	{
		return (item.Kind == EnvDTE.Constants.vsProjectItemKindPhysicalFolder);
	}

	private static string CreateSlug(string value, string className = "")
	{
		var result = value.Trim();

		result = Regex.Replace(result, @"[\W\b]", "_", RegexOptions.IgnoreCase);
		result = Regex.Replace(result, @"^\d", @"_$0");

		result = codeProvider.CreateEscapedIdentifier(result).Replace("@", "_");

		if (!string.IsNullOrEmpty(className) && string.Equals(className, result, StringComparison.InvariantCulture))
		{
			result = "_" + result;
		}

		return result;
	}

#>